
import { time, loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect } from "chai";
import { ethers } from "hardhat";
import { execSync } from "child_process";
import * as fs from "fs";
import * as path from "path";

describe("ArbiSecure Integration", function () {
    // Arbitrum Sepolia or Local Node
    const RPC_URL = process.env.ARBITRUM_SEPOLIA_RPC_URL || "http://127.0.0.1:8547";
    const WASM_PATH = path.join(__dirname, "../../contracts/target/wasm32-unknown-unknown/release/arbisecure_contracts.wasm");

    // Helper to deploy contract using cargo stylus
    async function deployArbiSecure() {
        console.log("Deploying ArbiSecure Stylus Contract...");

        // Ensure backend/.env has PRIVATE_KEY
        if (!process.env.PRIVATE_KEY) {
            console.warn("PRIVATE_KEY not set in .env. Using default local node account.");
            // Default account for nitro-testnode (Account #0)
            process.env.PRIVATE_KEY = "0xb6b15c8cb491557369f3c7d2c287b053eb229daa9c22138887752191c9520659";
        }

        try {
            // Command to deploy
            // returning the address by parsing output
            // We use --no-verify to speed up
            const cmd = `cargo stylus deploy --private-key ${process.env.PRIVATE_KEY} --endpoint ${RPC_URL} --wasm-file ${WASM_PATH} --no-verify`;
            console.log(`Running: ${cmd}`);
            const output = execSync(cmd, { encoding: "utf-8" });

            // Output usually contains: "Deployed to: 0x..." or "contract address: 0x..."
            // Let's assume standard output. 
            // If output format varies, we might need a regex.
            const match = output.match(/Deployed at address: (0x[a-fA-F0-9]{40})/);
            if (match) {
                return match[1];
            } else {
                // Try another pattern
                const match2 = output.match(/address: (0x[a-fA-F0-9]{40})/);
                if (match2) return match2[1];
            }
            console.error("Could not parse deployment address from output:", output);
            throw new Error("Deployment failed to return address");
        } catch (error) {
            console.error("Deployment failed:", error);
            throw error;
        }
    }

    async function getContract(address: string) {
        const ArbiSecure = await ethers.getContractFactory("IArbiSecure"); // Use Interface
        return ArbiSecure.attach(address);
    }

    it("Should create a deal, release milestone, and handle disputes", async function () {
        this.timeout(120000); // Allow time for deployment and txs

        // 1. Deploy
        // Note: For speed in local dev, we might want to deploy once.
        // But for integration test, new deployment is cleaner.
        const address = await deployArbiSecure();
        console.log("Contract deployed at:", address);

        const contract = await getContract(address);
        const [owner, freelancer, arbiter] = await ethers.getSigners();

        // 2. Initialize
        // Note: Stylus contracts usually initialize via a ctor-like method if transparent proxy, 
        // or just rely on storage being 0. 
        // Our contract has `initialize(address staking_token)`.
        const stakingToken = ethers.ZeroAddress; // ETH for now? Or mock token.
        // We'll use ZeroAddress as placeholder if contract allows.

        console.log("Initializing...");
        const txInit = await contract.initialize(stakingToken);
        await txInit.wait();

        // 3. Create Deal
        const dealId = 123;
        const amount = ethers.parseEther("0.01");
        // Tuple: (string, uint256, (uint8, uint256, address)[])
        const condition = [0, 0, ethers.ZeroAddress]; // ManualApproval
        const milestones = [
            ["Milestone 1", amount, [condition]]
        ];

        console.log("Creating deal...");
        const txCreate = await contract.createDeal(
            dealId,
            freelancer.address,
            arbiter.address,
            ethers.ZeroAddress, // ETH
            amount,
            milestones,
            { value: amount }
        );
        await txCreate.wait();

        // Verify Deal Count
        const dealCount = await contract.getDealCount();
        expect(dealCount).to.equal(1);

        // 4. Release Milestone
        console.log("Releasing milestone...");
        // releaseMilestone(deal_id, milestone_index)
        // deal_id is generated by counter. First deal is ID 0.
        // Wait, input `ref_id` was 123, but contract uses internal counter starting at 0.
        const internalDealId = 0;
        const milestoneIndex = 0;

        const txRelease = await contract.releaseMilestone(internalDealId, milestoneIndex);
        await txRelease.wait();

        // Verify state (via getters or events if possible)
        // We don't have a direct "getDealStatus" in ABI?
        // function getDealCount() is there.
        // IArbiSecure doesn't have getDeal struct getter because structs are hard to export in interface automatically?
        // Wait, IArbiSecure.sol generated by us DOES NOT have `getDeal`. 
        // We might need to add `getDeal` to interface if we want to check state, 
        // or rely on `getDealCount` and `hasUsedGaslessDeal`.

        // 5. Dispute Flow (Create another deal)
        console.log("Creating second deal for dispute...");
        const amount2 = ethers.parseEther("0.01");
        const txCreate2 = await contract.createDeal(
            456,
            freelancer.address,
            arbiter.address,
            ethers.ZeroAddress,
            amount2,
            milestones,
            { value: amount2 }
        );
        await txCreate2.wait();

        const disputeDealId = 1;

        console.log("Raising dispute...");
        // Raise dispute as Freelancer
        const contractAsFreelancer = contract.connect(freelancer);
        const txDispute = await contractAsFreelancer.raiseDispute(disputeDealId, "Not paying", "cid");
        await txDispute.wait();

        const disputeCount = await contract.getDisputeCount();
        expect(disputeCount).to.equal(1);

        console.log("Resolving dispute...");
        // Resolve as Arbiter
        const contractAsArbiter = contract.connect(arbiter);
        // resolveDispute(dispute_id, client_share, freelancer_share)
        // Dispute ID starts at 0?
        const disputeId = 0;
        const txResolve = await contractAsArbiter.resolveDispute(disputeId, amount2 / 2n, amount2 / 2n);
        await txResolve.wait();

        console.log("Test Complete!");
    });
});
